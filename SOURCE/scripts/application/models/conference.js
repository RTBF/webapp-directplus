// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['jquery', 'backbone', 'application/collections/slides', 'application/models/slide'], function($, Backbone, Slides, Slide) {
  var Conference;
  return Conference = (function(_super) {

    __extends(Conference, _super);

    Conference.prototype.defaults = {
      slidesC: new Slides()
    };

    function Conference(aConf) {
      Conference.__super__.constructor.call(this, aConf);
    }

    Conference.prototype.initialize = function() {
      var _this = this;
      this.get('slidesC').comparator = function() {
        var slide;
        slide = new Slide();
        return slide.get('Order');
      };
      this.get('slidesC').sort();
      this.navMode = false;
      this.on('slides', function(data) {
        return _this.restore(data);
      });
      this.on('newSlide', function(data) {
        return _this.newSlide(data);
      });
      this.on('next', function() {
        return _this.next();
      });
      this.on('previous', function() {
        return _this.previous();
      });
      return this.on('sremove', function(data) {
        return _this.remove(data);
      });
    };

    Conference.prototype.restore = function(data) {
      var len, max, obj, slide, slideLen, taille, x, _i;
      this.navMode = false;
      console.log("j'ai été restaurement");
      console.log(this.get('slidesC'));
      this.get('slidesC').fetch();
      len = data.length - 1;
      slideLen = this.get('slidesC').length - 1;
      if (slideLen !== len || data[0]._conf !== this.get('_id')) {
        console.log("jjj");
        this.get('slidesC').reset();
        localStorage.clear();
        this.get('slidesC').fetch();
        for (x = _i = 0; 0 <= len ? _i <= len : _i >= len; x = 0 <= len ? ++_i : --_i) {
          obj = $.parseJSON(data[x].JsonData);
          obj.id = data[x]._id;
          slide = new Slide(obj);
          this.get('slidesC').add(slide);
          slide.save();
          this.get('slidesC').fetch();
        }
      }
      this.get('slidesC').each(function(slide) {
        return slide.set('state', 'out');
      });
      taille = this.get('slidesC').length;
      max = 3;
      while (max > 0 && taille > 0) {
        taille--;
        slide = this.get('slidesC').at(taille);
        switch (max) {
          case 3:
            slide.set('state', 'current');
            break;
          case 2:
            slide.set('state', 'past');
            break;
          case 1:
            slide.set('state', 'far-past');
        }
        max--;
      }
      console.log(this.get('slidesC'));
      console.log(this.get('slidesC'));
      return this.trigger('change:slidesC');
    };

    Conference.prototype.newSlide = function(data) {
      var max, obj, slide, slideff, slidet, taille;
      obj = $.parseJSON(data.JsonData);
      obj.id = data._id;
      slide = new Slide(obj);
      if (this.navMode) {
        slideff = this.get('slidesC').where({
          state: 'far-future'
        });
        if (slideff[0]) {
          slide.set('state', 'out');
        } else {
          slide.set('state', 'far-future');
        }
      } else {
        slide.set('state', 'far-future');
        taille = this.get('slidesC').length;
        max = 3;
        while (max > 0 && taille > 0) {
          taille--;
          slidet = this.get('slidesC').at(taille);
          switch (max) {
            case 3:
              slidet.set('state', 'past');
              break;
            case 2:
              slidet.set('state', 'far-past');
              break;
            case 1:
              slidet.set('state', 'out');
          }
          max--;
        }
      }
      this.get('slidesC').add(slide);
      slide.save();
      this.get('slidesC').fetch;
      console.log(this.get('slidesC'));
      console.log("AAAAAAAAAreceived new slides");
      return this.trigger('new');
    };

    Conference.prototype.next = function() {
      var i, index, max, min, slideff, slidem;
      slideff = this.get('slidesC').where({
        state: 'current'
      });
      index = this.get('slidesC').indexOf(slideff[0]);
      if (index < this.get('slidesC').length - 1) {
        i = index;
        max = index;
        min = index - 1;
        while (max < this.get('slidesC').length && max < index + 5) {
          slidem = this.get('slidesC').at(max);
          switch (max) {
            case index:
              slidem.set('state', 'past');
              break;
            case index + 1:
              slidem.set('state', 'current');
              break;
            case index + 2:
              slidem.set('state', 'future');
              break;
            case index + 3:
              slidem.set('state', 'far-future');
              break;
            case index + 4:
              slidem.set('state', 'out');
          }
          max++;
        }
        while (min >= 0 && min > index - 3) {
          slidem = this.get('slidesC').at(min);
          switch (min) {
            case index - 1:
              slidem.set('state', 'far-past');
              break;
            case index - 2:
              slidem.set('state', 'out');
          }
          min--;
        }
      }
      if (index + 1 === this.get('slidesC').length - 1) {
        this.navMode = false;
      }
      return console.log(this.navMode);
    };

    Conference.prototype.previous = function() {
      var i, index, max, min, slideff, slidem;
      slideff = this.get('slidesC').where({
        state: 'current'
      });
      index = this.get('slidesC').indexOf(slideff[0]);
      if (index > 0) {
        i = index;
        max = index;
        min = index - 1;
        console.log("le i vaut", i);
        while ((max < this.get('slidesC').length) && (max < index + 3)) {
          slidem = this.get('slidesC').at(max);
          console.log(max);
          switch (max) {
            case i:
              slidem.set('state', 'future');
              break;
            case i + 1:
              slidem.set('state', 'far-future');
              break;
            case i + 2:
              slidem.set('state', 'out');
          }
          max++;
        }
        i = index - 1;
        console.log(min);
        while ((min >= 0) && (min > index - 4)) {
          slidem = this.get('slidesC').at(min);
          console.log("min vaut", min);
          switch (min) {
            case i:
              slidem.set('state', 'current');
              break;
            case i - 1:
              slidem.set('state', 'past');
              break;
            case i - 2:
              slidem.set('state', 'far-past');
              break;
            case i - 3:
              slidem.set('state', 'out');
          }
          min--;
        }
        this.navMode = true;
      }
      console.log(this.navMode);
      return console.log(this.get('slidesC'));
    };

    Conference.prototype.remove = function(data) {
      var currentPos, max, min, obj, removePos, slideToRemove, slideff, slidem, state, taille, _results, _results1, _results2;
      slideff = this.get('slidesC').where({
        state: 'current'
      });
      currentPos = this.get('slidesC').indexOf(slideff[0]);
      console.log("current pos", currentPos);
      obj = $.parseJSON(data.JsonData);
      slideToRemove = this.get('slidesC').get(data._id);
      state = slideToRemove.get("state");
      removePos = this.get('slidesC').indexOf(slideToRemove);
      this.get('slidesC').get(data._id).set('state', 'removed');
      this.get('slidesC').localStorage.destroy(this.get('slidesC').get(data._id));
      this.get('slidesC').remove(this.get('slidesC').get(data._id));
      if (state === 'current') {
        if (this.navMode) {
          taille = this.get('slidesC').length;
          max = currentPos;
          while (max < taille && max < currentPos + 4) {
            slidem = this.get('slidesC').at(max);
            switch (max) {
              case currentPos:
                slidem.set('state', 'current');
                break;
              case currentPos + 1:
                slidem.set('state', 'future');
                break;
              case currentPos + 2:
                slidem.set('state', 'far-future');
                break;
              case currentPos + 3:
                slidem.set('state', 'out');
            }
            max++;
          }
          if (this.get('slidesC').at(this.get('slidesC').length - 1).get('state') === "current") {
            return this.navMode = false;
          }
        } else {
          currentPos = currentPos - 1;
          min = currentPos;
          _results = [];
          while ((min >= 0) && (min > currentPos - 4)) {
            slidem = this.get('slidesC').at(min);
            switch (min) {
              case currentPos:
                slidem.set('state', 'current');
                break;
              case currentPos - 1:
                slidem.set('state', 'past');
                break;
              case currentPos - 2:
                slidem.set('state', 'far-past');
                break;
              case currentPos - 3:
                slidem.set('state', 'out');
            }
            _results.push(min--);
          }
          return _results;
        }
      } else {
        if (removePos > currentPos && removePos < currentPos + 3) {
          console.log('je suis au dessus du current');
          taille = this.get('slidesC').length;
          max = currentPos + 1;
          _results1 = [];
          while (max < taille && max < currentPos + 4) {
            slidem = this.get('slidesC').at(max);
            switch (max) {
              case currentPos + 1:
                slidem.set('state', 'future');
                break;
              case currentPos + 2:
                slidem.set('state', 'far-future');
                break;
              case currentPos + 3:
                slidem.set('state', 'out');
            }
            _results1.push(max++);
          }
          return _results1;
        } else {
          if (removePos < currentPos && removePos > currentPos - 3) {
            console.log("je suis en dessous du current");
            currentPos = currentPos - 1;
            min = currentPos - 1;
            _results2 = [];
            while ((min >= 0) && (min > currentPos - 3)) {
              slidem = this.get('slidesC').at(min);
              console.log("min vaut", min);
              switch (min) {
                case currentPos - 1:
                  slidem.set('state', 'past');
                  break;
                case currentPos - 2:
                  slidem.set('state', 'far-past');
                  break;
                case currentPos - 3:
                  slidem.set('state', 'out');
              }
              _results2.push(min--);
            }
            return _results2;
          }
        }
      }
    };

    return Conference;

  })(Backbone.Model);
});
